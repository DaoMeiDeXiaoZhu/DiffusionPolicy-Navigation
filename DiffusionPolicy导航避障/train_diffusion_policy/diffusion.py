import torch
import torch.nn.functional as F

class Diffusion(torch.nn.Module):
    def __init__(self, timesteps=1000, beta_start=1e-4, beta_end=0.02):
        super().__init__()

        # ---------------------------------------------------------
        # 1. 构造线性增长的 beta_t（噪声强度）
        #    beta_t ∈ [1e-4, 0.02]，共 timesteps 个
        #    对应论文中的 β_t
        # ---------------------------------------------------------
        betas = torch.linspace(beta_start, beta_end, timesteps)

        # ---------------------------------------------------------
        # 2. 计算 α_t = 1 - β_t
        #    对应论文中的 α_t
        # ---------------------------------------------------------
        alphas = 1.0 - betas

        # ---------------------------------------------------------
        # 3. 计算 ᾱ_t = ∏_{i=1..t} α_i
        #    对应前向扩散公式中的累计乘积
        #    ᾱ_t 越小，噪声越大
        # ---------------------------------------------------------
        alpha_bar = torch.cumprod(alphas, dim=0)

        # ---------------------------------------------------------
        # 4. 注册为 buffer（不是参数，不参与训练）
        #    这样 model.to(device) 时它们会自动移动到 GPU
        # ---------------------------------------------------------
        self.register_buffer("betas", betas)          # (T,)
        self.register_buffer("alphas", alphas)        # (T,)
        self.register_buffer("alpha_bar", alpha_bar)  # (T,)

        # 总扩散步数 T
        self.T = timesteps

    # =====================================================================
    # 前向扩散 q(x_t | x_0)
    # 对应公式：
    #   x_t = sqrt(ᾱ_t) * x_0 + sqrt(1 - ᾱ_t) * ε
    # =====================================================================
    def q_sample(self, x0, t, noise=None):
        """
        x0:    (B, T, action_dim)   原始专家动作序列
        t:     (B,)                 随机采样的扩散时间步
        noise: (B, T, action_dim)   高斯噪声 ε
        """

        # 如果没有传入噪声，则自动生成标准正态噪声 ε
        if noise is None:
            noise = torch.randn_like(x0)

        # ---------------------------------------------------------
        # 从 alpha_bar 中取出对应 batch 的 ᾱ_t
        # shape: (B,) → reshape 为 (B,1,1) 方便广播
        # ---------------------------------------------------------
        a_bar = self.alpha_bar[t].reshape(-1, 1, 1)

        # ---------------------------------------------------------
        # 前向扩散公式：
        # x_t = sqrt(ᾱ_t) * x_0 + sqrt(1 - ᾱ_t) * ε
        # ---------------------------------------------------------
        x_t = torch.sqrt(a_bar) * x0 + torch.sqrt(1.0 - a_bar) * noise

        # 返回 x_t 和噪声 ε（训练时需要用 ε 做 MSE）
        return x_t, noise

    # =====================================================================
    # 反向扩散 p(x_{t-1} | x_t)
    # 对应公式：
    #   x_{t-1} = 1/sqrt(α_t) * (x_t - β_t/sqrt(1-ᾱ_t) * εθ(x_t))
    #             + sqrt(β_t) * z
    # =====================================================================
    def p_sample(self, model, obs, x_t, t):
        """
        model: 噪声预测网络 εθ
        obs:   观测（图像 + 雷达）
        x_t:   当前带噪动作
        t:     当前扩散步
        """

        # ---------------------------------------------------------
        # 1. 预测噪声 εθ(x_t, o, t)
        # ---------------------------------------------------------
        pred_noise = model(
            img=obs["img"],
            state=obs["state"],
            noisy_action=x_t,
            t=t
        )

        # ---------------------------------------------------------
        # 2. 取出 β_t, α_t, ᾱ_t，并 reshape 成 (B,1,1)
        # ---------------------------------------------------------
        beta_t = self.betas[t].reshape(-1, 1, 1)
        alpha_t = self.alphas[t].reshape(-1, 1, 1)
        alpha_bar_t = self.alpha_bar[t].reshape(-1, 1, 1)

        # ---------------------------------------------------------
        # 3. 计算反向扩散的均值项（去噪）
        #    mean = 1/sqrt(α_t) * (x_t - β_t/sqrt(1-ᾱ_t) * εθ)
        # ---------------------------------------------------------
        mean = (1.0 / torch.sqrt(alpha_t)) * (
            x_t - beta_t / torch.sqrt(1.0 - alpha_bar_t) * pred_noise
        )

        # ---------------------------------------------------------
        # 4. t = 0 时不再加噪声，直接返回均值
        # ---------------------------------------------------------
        if (t == 0).all():
            return mean

        # ---------------------------------------------------------
        # 5. 反向扩散的随机项：sqrt(β_t) * z
        #    z ~ N(0, I)
        # ---------------------------------------------------------
        noise = torch.randn_like(x_t)

        # 返回 x_{t-1}
        return mean + torch.sqrt(beta_t) * noise
